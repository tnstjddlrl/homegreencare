
import React, { useRef, useEffect, useState, useCallback } from 'react';
import {
  Alert,
  SafeAreaView,
  ScrollView,
  StatusBar,
  StyleSheet,
  Text,
  useColorScheme,
  View,
  BackHandler,
  ActivityIndicator
} from 'react-native';

import { WebView } from 'react-native-webview';

import RNExitApp from 'react-native-exit-app';

import TouchID from 'react-native-touch-id';

import DeviceInfo, { getUniqueId } from 'react-native-device-info';

import messaging from '@react-native-firebase/messaging';
import firebase from '@react-native-firebase/app'
import PushNotification, { Importance } from 'react-native-push-notification';

import { check, PERMISSIONS, RESULTS, checkNotifications, requestNotifications } from 'react-native-permissions';

import RNRestart from 'react-native-restart';

var rnw
var cbc = false;

function pnf(messageId, channelId, title, body) {
  PushNotification.localNotification({
    /* Android Only Properties */
    channelId: 'fcm_alert', // (required) channelId, if the channel doesn't exist, notification will not trigger.
    vibrate: true, // (optional) default: true
    vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
    onlyAlertOnce: true, // (optional) alert will open only once with sound and notify, default: false

    // messageId: messageId, // (optional) added as `message_id` to intent extras so opening push notification can find data stored by @react-native-firebase/messaging module. 

    /* iOS only properties */
    category: "", // (optional) default: empty string
    subtitle: "", // (optional) smaller title below notification title

    /* iOS and Android properties */
    id: messageId, // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
    title: title, // (optional)
    message: body, // (required)
    playSound: false, // (optional) default: true
    soundName: "default", // (optional) Sound to play when the noti
  });
}

const App = () => {

  async function requestUserPermission() {
    const authStatus = await messaging().requestPermission();
    const enabled =
      authStatus === messaging.AuthorizationStatus.AUTHORIZED ||
      authStatus === messaging.AuthorizationStatus.PROVISIONAL;

    if (enabled) {
      console.log('Authorization status:', authStatus);
    } else {
      console.log('Authorization status:??', authStatus);
    }
  }

  useEffect(() => {
    const unsubscribe = messaging().onMessage(async remoteMessage => {
      console.log(remoteMessage)
      // Alert.alert(JSON.stringify(remoteMessage.notification.title).replace(/"/gi, ""), JSON.stringify(remoteMessage.notification.body).replace(/"/gi, ""));
      pnf(JSON.stringify(remoteMessage.messageId).replace(/"/gi, ""), JSON.stringify(remoteMessage.notification.android.channelId).replace(/"/gi, ""), JSON.stringify(remoteMessage.notification.title).replace(/"/gi, ""), JSON.stringify(remoteMessage.notification.body).replace(/"/gi, ""))
    });

    return unsubscribe;
  }, []);

  useEffect(() => {
    const backHandler = BackHandler.addEventListener(
      "hwbp",
      function () {
        if (cbc && rnw) {
          rnw.goBack();
          return true;
        } else if (cbc == false) {
          Alert.alert('앱을 종료하시겠습니까?', '', [
            {
              text: "No",
              onPress: () => console.log("Cancel Pressed")
            },
            { text: "Yes", onPress: () => RNExitApp.exitApp() }
          ])
          return true;
        }
      }
    );
    return () => backHandler.remove();
  }, []);

  const optionalConfigObject = {
    title: '지문인식 필요', // Android
    imageColor: '#e00606', // Android
    imageErrorColor: '#ff0000', // Android
    sensorDescription: '터치 센서', // Android
    sensorErrorDescription: '실패', // Android
    cancelText: '취소', // Android
    fallbackLabel: '비밀번호 입력', // iOS (if empty, then label is hidden)
    unifiedErrors: false, // use unified error messages (default false)
    passcodeFallback: false, // iOS - allows the device to fall back to using the passcode, if faceid/touch is not available. this does not mean that if touchid/faceid fails the first few times it will revert to passcode, rather that if the former are not enrolled, then it will use the passcode.
  };

  function touch(id) {
    TouchID.authenticate('생체 인식', optionalConfigObject)
      .then(success => {
        console.log(success)
        rnw.postMessage(id + '/1')
        console.log('전송 : ' + id + '/1')
        Alert.alert('생체 인식 성공!')
      }).catch(error => {
        // Failure code
        // Alert.alert('지문 인식 오류 발생!')
        console.log(success)
        rnw.postMessage(id + '/0')
        console.log('전송 : ' + id + '/0')
        Alert.alert('생체 인식 실패!')
      });
  }

  function touchlogin(id) {
    TouchID.authenticate('생체 인식', optionalConfigObject)
      .then(success => {
        console.log('석세스 : ' + success)
        rnw.postMessage(id + '/ok')
        console.log('전송 : ' + id + '/ok')
        Alert.alert('생체 인식 성공!')
      }).catch(error => {
        // Failure code
        rnw.postMessage(id + '/fail')
        console.log('전송 : ' + id + '/fail')
        Alert.alert('생체 인식 실패!')

        setTimeout(() => {
          RNRestart.Restart();
        }, 1000);
      });
  }

  ///////////////////////////////////////////////////////////////////////////////
  const [pushToken, setPushToken] = useState('')
  const [isAuthorized, setIsAuthorized] = useState(false)

  const handlePushToken = useCallback(async () => {
    console.log('핸들푸시 실행!')
    const enabled = await messaging().hasPermission()
    if (enabled) {
      const fcmToken = await messaging().getToken()
      if (fcmToken) {
        setPushToken(fcmToken)
        console.log('토큰이 있다! ' + fcmToken)
      }
      else
        console.log('토큰이 없다!')
    } else {
      console.log('얘뭐지?' + enabled)
      const authorized = await messaging().requestPermission();
      if (authorized) setIsAuthorized(true)
      else {
        console.log('결국 안됨')
        console.log(authorized)
      }
    }
  }, [])


  const saveDeviceToken = useCallback(async () => {
    console.log('savedevicetoken')
    if (isAuthorized) {
      const currentFcmToken = await firebase.messaging().getToken()
      if (currentFcmToken !== pushToken) {
        return setPushToken(currentFcmToken)
      }
      return messaging().onTokenRefresh((token) => setPushToken(token))
    } else {
      console.log('savedevicetoken isAuthorized : ' + isAuthorized)
    }
  }, [pushToken, isAuthorized])

  useEffect(() => {

    checkNotifications().then(({ status, settings }) => {
      console.log('스테이터스 : ' + status);

      if (status === 'blocked') {

        requestUserPermission()
        messaging().requestPermission()

        requestNotifications(['alert', 'sound']).then(({ status, settings }) => {
          console.log('스테이터스 : ' + status);

          if (status === 'blocked') {

            requestUserPermission()
            messaging().requestPermission()
            Alert.alert('앱을 재설치하여 알림 권한을 허용해주세요!')

          } else {

          }
        });
      } else {

      }
      console.log('세팅 : ' + settings);
      console.log(settings)
    });

    try {
      messaging().requestPermission();
      requestUserPermission().then(() => {
        try {
          handlePushToken()
          saveDeviceToken()
        } catch (error) {
          console.log(error)
          Alert.alert('토큰 받아오기 실패')
        }
      })
    } catch (error) {
      console.log(error)
      Alert.alert('토큰 받아오기 실패')

    }
  }, [])

  useEffect(() => {

    console.log('토큰받아오기 : ' + pushToken)
    // openSettings().catch(() => console.warn('cannot open settings'));

  }, [pushToken])
  ///////////////////////////////////////////////////////////////////////////////


  function onMessage(event) {

    console.log(event.nativeEvent.data);

    if (event.nativeEvent.data == 'touchLogin') {
      try {
        let uniqueId = getUniqueId();
        touchlogin(uniqueId)
      } catch (error) {
        console.log(error)
        Alert.alert('나중에 다시 시도해주세요.', '증상이 계속되면 고객센터로 연락주세요.', [
          { text: "확인", onPress: () => RNExitApp.exitApp() }
        ])
      }
    }

    if (event.nativeEvent.data == 'deviceid') {
      try {
        let uniqueId = getUniqueId();
        rnw.postMessage(uniqueId)
        console.log('전송 : ' + uniqueId)
      } catch (error) {
        console.log(error)
        Alert.alert('나중에 다시 시도해주세요.', '증상이 계속되면 고객센터로 연락주세요.', [
          { text: "확인", onPress: () => RNExitApp.exitApp() }
        ])
      }
    }

    if (event.nativeEvent.data == 'deviceid/check') {
      try {
        let uniqueId = getUniqueId();
        touch(uniqueId)
        // rnw.postMessage(uniqueId + '/1')
        // console.log('전송 : ' + uniqueId + '/1')
      } catch (error) {
        console.log(error)
        Alert.alert('나중에 다시 시도해주세요.', '증상이 계속되면 고객센터로 연락주세요.', [
          { text: "확인", onPress: () => RNExitApp.exitApp() }
        ])
      }
    }

    if (event.nativeEvent.data == 'token') {
      rnw.postMessage(pushToken)
      console.log('전송 : ' + pushToken)
    }
  }

  useEffect(() => {
    // touch()
    let uniqueId = getUniqueId();
    console.log('유니크 아이디 : ' + uniqueId)
  }, [])

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <WebView
        ref={wb => { rnw = wb }}
        onMessage={event => {
          onMessage(event)
        }}
        onLoadEnd={() => {
          // rnw.postMessage('hello')
        }}
        source={{ uri: 'https://homegreencare001.cafe24.com/' }}
        style={{ width: '100%', height: '100%' }}
        onNavigationStateChange={(navState) => { cbc = navState.canGoBack; }}
      />
    </SafeAreaView>
  )
}



export default App;
